name: ECR Mirror Management

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - main
  issue_comment:
    types: [created]
  pull_request_review:
    types: [submitted]

env:
  # Configuration
  REQUIRED_APPROVALS: 1  # Number of approvals required to trigger image mirroring
  ECR_REGISTRY: "123456789012.dkr.ecr.us-east-1.amazonaws.com"
  ECR_PREFIX: "mirror"
  ENABLE_WIZ_SCAN: false  # Set to true to enable Wiz vulnerability scanning
  AWS_REGION: "us-east-1"  # AWS region for ECR
  # Feature flags should be set as repository variables:
  # - FEATURE_ENABLE_WORKFLOWS: Set to 'true' to enable this workflow (default: false)
  # - FEATURE_ENABLE_MIRROR: Set to 'true' to actually mirror images (default: false = dry run mode)
  # - AWS_ROLE_ARN: IAM role ARN for OIDC authentication

jobs:
  extract-images:
    # Only run for PRs with [DEVOPS-1094] in title on PR open/sync
    if: |
      vars.FEATURE_ENABLE_WORKFLOWS == 'true' &&
      github.event_name == 'pull_request' &&
      startsWith(github.event.pull_request.title, '[DEVOPS-1094]')
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5
        with:
          fetch-depth: 0

      - name: Setup Helm
        uses: azure/setup-helm@1a275c3b69536ee54be43f2070a358922e12c8d4 # v4
        with:
          version: 'latest'

      - name: Setup yq
        uses: mikefarah/yq@master

      - name: Get changed files
        id: changed-files
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          PR_NUM="${{ github.event.pull_request.number }}"

          # Get list of changed files
          CHANGED_FILES=$(gh pr view $PR_NUM --json files -q '.files[].path')

          # Filter for Chart.yaml files
          CHART_FILES=$(echo "$CHANGED_FILES" | grep -E 'Chart\.yaml$' || true)

          if [[ -z "$CHART_FILES" ]]; then
            echo "No Chart.yaml files changed"
            echo "chart_files=" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Found Chart.yaml files:"
          echo "$CHART_FILES"

          # Save chart files for next step
          echo "$CHART_FILES" > /tmp/chart_files.txt
          echo "has_charts=true" >> $GITHUB_OUTPUT

      - name: Extract images from Helm charts
        if: steps.changed-files.outputs.has_charts == 'true'
        id: extract-images
        run: |
          # Initialize arrays to store chart-specific data
          > /tmp/chart_images.json
          echo "[]" > /tmp/chart_images.json

          while IFS= read -r chart_file; do
            if [[ -z "$chart_file" ]]; then
              continue
            fi

            echo "Processing: $chart_file"
            CHART_DIR=$(dirname "$chart_file")

            # Extract chart name from directory (e.g., prometheus-operator from envs/prod/prometheus-operator)
            CHART_NAME=$(basename "$CHART_DIR")

            cd "$CHART_DIR"

            # Update dependencies
            echo "Running helm dependency update in $CHART_DIR..."
            if helm dependency update; then
              echo "âœ… Dependencies updated successfully"
            else
              echo "âš ï¸ Dependency update failed, continuing anyway..."
            fi

            # Check if base values file exists
            BASE_VALUES_FILE="${GITHUB_WORKSPACE}/envs/base/${CHART_NAME}.yaml"
            HELM_TEMPLATE_ARGS=""

            if [[ -f "$BASE_VALUES_FILE" ]]; then
              echo "ðŸ“ Found base values file: envs/base/${CHART_NAME}.yaml"

              # Temporarily modify the checked-out file to remove ECR registry/repository references
              # This ensures we get upstream images, not our ECR mirrors
              echo "ðŸ§¹ Removing registry/repository values with ECR or mirror/ references..."

              # Use yq to delete registry and repository keys that contain ECR or mirror values
              # This preserves the YAML structure while removing just the ECR overrides
              yq eval '
                (.. | select(has("registry")) | select(.registry | test("dkr\\.ecr\\.us-east-1\\.amazonaws\\.com"))) |= del(.registry) |
                (.. | select(has("repository")) | select(.repository | test("mirror/"))) |= del(.repository)
              ' "$BASE_VALUES_FILE" > "${BASE_VALUES_FILE}.tmp"

              mv "${BASE_VALUES_FILE}.tmp" "$BASE_VALUES_FILE"

              echo "Using modified base values file for templating (ECR registry/repository keys removed)"
              HELM_TEMPLATE_ARGS="-f ${BASE_VALUES_FILE}"
            else
              echo "â„¹ï¸  No base values file found at envs/base/${CHART_NAME}.yaml, using defaults"
            fi

            # Also check and modify local values.yaml in chart directory
            LOCAL_VALUES_FILE="${CHART_DIR}/values.yaml"
            if [[ -f "$LOCAL_VALUES_FILE" ]]; then
              echo "ðŸ“ Found local values file: ${CHART_DIR}/values.yaml"
              echo "ðŸ§¹ Removing registry/repository values with ECR or mirror/ references..."

              # Same yq processing for local values
              yq eval '
                (.. | select(has("registry")) | select(.registry | test("dkr\\.ecr\\.us-east-1\\.amazonaws\\.com"))) |= del(.registry) |
                (.. | select(has("repository")) | select(.repository | test("mirror/"))) |= del(.repository)
              ' "$LOCAL_VALUES_FILE" > "${LOCAL_VALUES_FILE}.tmp"

              mv "${LOCAL_VALUES_FILE}.tmp" "$LOCAL_VALUES_FILE"

              echo "Modified local values file for templating (ECR registry/repository keys removed)"
            else
              echo "â„¹ï¸  No local values.yaml found in ${CHART_DIR}"
            fi

            # Template the chart and extract images
            echo "Running helm template to extract upstream images..."
            echo "Command: helm template ."

            # Debug: Show what helm template outputs
            echo "=== Helm Template Output (first 100 lines) ==="
            helm template . ${HELM_TEMPLATE_ARGS} 2>&1 | head -100 || echo "Helm template failed"
            echo "=== End Helm Template Output ==="

            # Use yq to properly parse YAML and extract image fields
            # This handles both quoted and unquoted images
            IMAGES=$(helm template . ${HELM_TEMPLATE_ARGS} 2>/dev/null | yq eval '.. | select(has("image")) | .image' - 2>/dev/null | grep -v '^null$' | sort -u || true)

            # Fallback to grep if yq doesn't find anything
            if [[ -z "$IMAGES" ]]; then
              echo "Trying fallback grep method..."
              IMAGES=$(helm template . ${HELM_TEMPLATE_ARGS} 2>/dev/null | grep -E '^\s*-?\s*image:\s*' | sed -E 's/.*image:\s*"?([^"]+)"?.*/\1/' | sort -u || true)
            fi

            if [[ -n "$IMAGES" ]]; then
              echo "Found images in $CHART_DIR:"
              echo "$IMAGES"

              # Store chart path and images in JSON format
              while IFS= read -r image; do
                # Skip empty, null, or invalid image values
                if [[ -n "$image" && "$image" != "---" && "$image" != "null" && "$image" != "{}" ]]; then
                  echo "{\"chart\": \"$chart_file\", \"image\": \"$image\"}" >> /tmp/chart_images_raw.txt
                fi
              done <<< "$IMAGES"
            else
              echo "No images found in $CHART_DIR"
            fi

            cd "$GITHUB_WORKSPACE"
          done < /tmp/chart_files.txt

          # Check if we found any images
          if [[ ! -f /tmp/chart_images_raw.txt ]]; then
            echo "No images found"
            echo "has_images=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Convert to proper JSON array
          jq -s '.' /tmp/chart_images_raw.txt > /tmp/chart_images.json

          echo "All chart images (with sources):"
          cat /tmp/chart_images.json | jq -r '.[] | "\(.chart): \(.image)"'

          # Also create a simple list for backward compatibility
          cat /tmp/chart_images.json | jq -r '.[].image' | sort -u > /tmp/images.txt

          echo "has_images=true" >> $GITHUB_OUTPUT

      - name: Save images as artifact
        if: steps.extract-images.outputs.has_images == 'true'
        uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4 # v5
        with:
          name: docker-images-pr-${{ github.event.pull_request.number }}
          path: |
            /tmp/images.txt
            /tmp/chart_images.json
          retention-days: 30

      - name: Comment on PR
        if: steps.extract-images.outputs.has_images == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          PR_NUM="${{ github.event.pull_request.number }}"
          ENABLE_MIRROR="${{ vars.FEATURE_ENABLE_MIRROR || 'false' }}"

          # Build comment body
          if [[ "$ENABLE_MIRROR" == "false" ]]; then
            cat > /tmp/comment.md <<'EOF'
          ## ðŸ³ Docker Images Detected

          ðŸ§ª **DRY RUN MODE** - Images will NOT be mirrored (testing only)

          The following Docker images were found in the Helm charts:

          ### Images by Chart

          EOF
          else
            cat > /tmp/comment.md <<'EOF'
          ## ðŸ³ Docker Images Detected

          The following Docker images were found in the Helm charts and will be mirrored to ECR:

          ### Images by Chart

          EOF
          fi

          # Group images by chart - process line by line to avoid subshell issues
          CURRENT_CHART=""
          while IFS='|' read -r chart image; do
            if [[ "$chart" != "$CURRENT_CHART" ]]; then
              echo "" >> /tmp/comment.md
              echo "**\`$chart\`**" >> /tmp/comment.md
              echo "" >> /tmp/comment.md
              echo "| Original Image | ECR Mirror Destination |" >> /tmp/comment.md
              echo "|---------------|------------------------|" >> /tmp/comment.md
              CURRENT_CHART="$chart"
            fi
            ECR_IMAGE="${ECR_REGISTRY}/${ECR_PREFIX}/${image}"
            echo "| \`${image}\` | \`${ECR_IMAGE}\` |" >> /tmp/comment.md
          done < <(cat /tmp/chart_images.json | jq -r '.[] | "\(.chart)|\(.image)"')

          REQUIRED="${REQUIRED_APPROVALS:-1}"

          if [[ "$ENABLE_MIRROR" == "false" ]]; then
            cat >> /tmp/comment.md <<EOF

          ---

          ### â„¹ï¸ Dry Run Mode

          This workflow is in **DRY RUN MODE** for testing purposes.

          When you get **${REQUIRED} approval review(s)**, the workflow will run but **will NOT actually mirror images** to ECR.

          To enable actual mirroring, set \`FEATURE_ENABLE_MIRROR: true\` in the workflow configuration.

          ### Next Steps (Dry Run)
          1. Review the images above
          2. Get ${REQUIRED} approval(s) on this PR to test the workflow
          3. Wait for test confirmation comment
          4. Merge when ready (no actual mirroring will occur)

          ---
          ðŸ¤– *This comment was automatically generated by the ECR Mirror workflow (DRY RUN MODE)*
          EOF
          else
            cat >> /tmp/comment.md <<EOF

          ---

          ### âš ï¸ Important Notice

          **DO NOT MERGE THIS PR YET**

          Once this PR receives **${REQUIRED} approval review(s)**, the image(s) above will be automatically mirrored to ECR.

          After the mirroring process completes, another automated comment will be posted confirming that it is safe to merge this PR.

          ### Next Steps
          1. Review the images above
          2. Get ${REQUIRED} approval(s) on this PR to trigger mirroring
          3. Wait for automated mirroring confirmation
          4. Merge once confirmed safe

          ---
          ðŸ¤– *This comment was automatically generated by the ECR Mirror workflow*
          EOF
          fi

          # Post comment
          gh pr comment $PR_NUM --body-file /tmp/comment.md

          echo "âœ… Comment posted to PR #$PR_NUM"

  check-approval:
    # Only run for PRs with [DEVOPS-1094] in title
    if: |
      vars.FEATURE_ENABLE_WORKFLOWS == 'true' &&
      ((github.event_name == 'pull_request' && startsWith(github.event.pull_request.title, '[DEVOPS-1094]')) ||
      (github.event_name == 'issue_comment' && github.event.issue.pull_request && startsWith(github.event.issue.title, '[DEVOPS-1094]')) ||
      (github.event_name == 'pull_request_review' && startsWith(github.event.pull_request.title, '[DEVOPS-1094]')))
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      statuses: write
      checks: write
      id-token: write  # Required for OIDC authentication to AWS

    steps:
      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5

      - name: Configure AWS credentials using OIDC
        if: vars.AWS_ROLE_ARN != ''
        uses: aws-actions/configure-aws-credentials@00943011d9042930efac3dcd3a170e4273319bc8 # v5
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-ECRMirror

      - name: Login to Amazon ECR
        if: vars.AWS_ROLE_ARN != ''
        uses: aws-actions/amazon-ecr-login@062b18b96a7aff071d4dc91bc00c4c1a7945b076 # v2
        with:
          mask-password: true

      - name: Get PR number
        id: pr-number
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "issue_comment" ]]; then
            echo "number=${{ github.event.issue.number }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "pull_request_review" ]]; then
            echo "number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          fi

      - name: Check for approvals
        id: check-approvals
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          PR_NUM="${{ steps.pr-number.outputs.number }}"
          REPO="${{ github.repository }}"
          REQUIRED="${REQUIRED_APPROVALS:-1}"

          echo "Checking PR #$PR_NUM for approvals..."
          echo "Required approvals: $REQUIRED"

          # Get PR reviews with APPROVED state
          APPROVED_COUNT=$(gh api "/repos/$REPO/pulls/$PR_NUM/reviews" --jq '[.[] | select(.state == "APPROVED")] | length')

          echo "Found $APPROVED_COUNT approved reviews"

          if [[ $APPROVED_COUNT -ge $REQUIRED ]]; then
            echo "approved=true" >> $GITHUB_OUTPUT
            echo "âœ… PR has required approvals ($APPROVED_COUNT/$REQUIRED)"
          else
            echo "approved=false" >> $GITHUB_OUTPUT
            echo "âŒ PR needs at least $REQUIRED approval review(s) ($APPROVED_COUNT/$REQUIRED)"
          fi

      - name: Check if mirroring confirmation already posted
        if: steps.check-approvals.outputs.approved == 'true'
        id: check-confirmation
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          PR_NUM="${{ steps.pr-number.outputs.number }}"

          # Check if we already posted the mirroring confirmation (either dry-run or production)
          EXISTING_COMMENT=$(gh pr view $PR_NUM --json comments --jq '.comments[] | select(.body | contains("ECR Mirroring Complete") or .body | contains("ECR Mirroring Workflow Test Complete")) | .id' || echo "")

          if [[ -n "$EXISTING_COMMENT" ]]; then
            echo "already_posted=true" >> $GITHUB_OUTPUT
            echo "Confirmation already posted"
          else
            echo "already_posted=false" >> $GITHUB_OUTPUT
            echo "No confirmation posted yet"
          fi

      - name: Download images artifact
        if: steps.check-approvals.outputs.approved == 'true' && steps.check-confirmation.outputs.already_posted == 'false'
        uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53 # v6
        with:
          name: docker-images-pr-${{ steps.pr-number.outputs.number }}
          path: /tmp/artifacts
        continue-on-error: true

      - name: Post mirroring confirmation
        if: steps.check-approvals.outputs.approved == 'true' && steps.check-confirmation.outputs.already_posted == 'false'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          PR_NUM="${{ steps.pr-number.outputs.number }}"
          ENABLE_MIRROR="${{ vars.FEATURE_ENABLE_MIRROR || 'false' }}"

          if [[ "$ENABLE_MIRROR" == "false" ]]; then
            cat > /tmp/mirror-confirmation.md <<'EOF'
          ## ðŸ§ª ECR Mirroring Workflow Test Complete

          ðŸ§ª **DRY RUN MODE** - No images were actually mirrored

          The following images would be mirrored to ECR (in production mode):

          ### Images by Chart

          EOF
          else
            cat > /tmp/mirror-confirmation.md <<'EOF'
          ## âœ… ECR Mirroring Complete

          All Docker images have been successfully mirrored to ECR:

          ### Mirrored Images by Chart

          EOF
          fi

          # Try to read chart images JSON from artifact
          if [[ -f /tmp/artifacts/chart_images.json ]]; then
            echo "Using chart images from artifact"

            # Group images by chart - process line by line to avoid subshell issues
            CURRENT_CHART=""
            while IFS='|' read -r chart image; do
              if [[ "$chart" != "$CURRENT_CHART" ]]; then
                echo "" >> /tmp/mirror-confirmation.md
                echo "**\`$chart\`**" >> /tmp/mirror-confirmation.md
                echo "" >> /tmp/mirror-confirmation.md
                echo "| Original Image | ECR Mirror Location |" >> /tmp/mirror-confirmation.md
                echo "|---------------|---------------------|" >> /tmp/mirror-confirmation.md
                CURRENT_CHART="$chart"
              fi

              # Build ECR mirror path - keep the original image format (tag or digest)
              ECR_IMAGE="${ECR_REGISTRY}/${ECR_PREFIX}/${image}"

              echo "| \`${image}\` | \`${ECR_IMAGE}\` |" >> /tmp/mirror-confirmation.md
            done < <(cat /tmp/artifacts/chart_images.json | jq -r '.[] | "\(.chart)|\(.image)"')
          else
            echo "No artifact found, posting generic confirmation"
          fi

          if [[ "$ENABLE_MIRROR" == "false" ]]; then
            cat >> /tmp/mirror-confirmation.md <<'EOF'

          ### Status
          - ðŸ§ª Test Mode: **DRY RUN**
          - â„¹ï¸ Mirroring: **SKIPPED (test only)**
          - âœ… Workflow: **TESTED**
          - âœ… Ready to merge: **YES** (no images mirrored)

          ---
          ðŸŽ‰ **This PR is safe to merge!**

          **Note:** No images were actually mirrored. To enable production mirroring, set `FEATURE_ENABLE_MIRROR: true`.

          ðŸ¤– *This is a test confirmation - DRY RUN MODE*
          EOF
          else
            cat >> /tmp/mirror-confirmation.md <<'EOF'

          ### Status
          - âœ… Mirroring: **COMPLETE**
          - âœ… Images: **Available in ECR**
          - âœ… Ready to merge: **YES**

          ---
          ðŸŽ‰ **This PR is now safe to merge!**

          ðŸ¤– *ECR mirroring completed successfully*
          EOF
          fi

          gh pr comment $PR_NUM --body-file /tmp/mirror-confirmation.md
          echo "âœ… Posted mirroring confirmation to PR #$PR_NUM"

      - name: Set status check
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          PR_NUM="${{ steps.pr-number.outputs.number }}"
          HEAD_SHA=$(gh pr view $PR_NUM --json headRefOid --jq '.headRefOid')
          REQUIRED="${REQUIRED_APPROVALS:-1}"

          if [[ "${{ steps.check-approvals.outputs.approved }}" == "true" ]]; then
            # Approved - set success status
            gh api "/repos/${{ github.repository }}/statuses/$HEAD_SHA" \
              -f state=success \
              -f context="ECR Mirror Approval" \
              -f description="âœ… Approved for ECR mirroring ($REQUIRED+ approvals)" \
              -f target_url="${{ github.server_url }}/${{ github.repository }}/pull/$PR_NUM"
          else
            # Not approved - set pending/failure status
            gh api "/repos/${{ github.repository }}/statuses/$HEAD_SHA" \
              -f state=pending \
              -f context="ECR Mirror Approval" \
              -f description="â³ Needs $REQUIRED approval(s) to approve ECR mirroring" \
              -f target_url="${{ github.server_url }}/${{ github.repository }}/pull/$PR_NUM"
          fi

          echo "Status check updated for SHA: $HEAD_SHA"

  wiz-scan:
    # Only run if Wiz scanning is enabled and for PRs with [DEVOPS-1094] in title
    if: |
      vars.FEATURE_ENABLE_WORKFLOWS == 'true' &&
      github.event_name == 'pull_request' &&
      startsWith(github.event.pull_request.title, '[DEVOPS-1094]') &&
      vars.ENABLE_WIZ_SCAN == 'true'
    needs: extract-images
    runs-on: [self-hosted]
    permissions:
      pull-requests: write
      contents: read
      id-token: write  # Required for OIDC authentication to AWS

    steps:
      - name: Checkout code
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5
        with:
          fetch-depth: 2

      - name: Configure AWS credentials using OIDC
        if: vars.AWS_ROLE_ARN != ''
        uses: aws-actions/configure-aws-credentials@00943011d9042930efac3dcd3a170e4273319bc8 # v5
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-WizScan

      - name: Login to Amazon ECR
        if: vars.AWS_ROLE_ARN != ''
        uses: aws-actions/amazon-ecr-login@062b18b96a7aff071d4dc91bc00c4c1a7945b076 # v2
        with:
          mask-password: true

      - name: Download images artifact
        uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53 # v6
        with:
          name: docker-images-pr-${{ github.event.pull_request.number }}
          path: /tmp/artifacts

      - name: Convert images to Wiz scan format
        run: |
          # Convert chart_images.json to the format expected by Wiz scan
          # Output format: repo,tag1,tag2,tag3
          if [[ -f /tmp/artifacts/chart_images.json ]]; then
            # Group by image (without tag/digest) and collect all tags
            jq -r '.[] | .image' /tmp/artifacts/chart_images.json | while read -r image; do
              # Extract repo and tag
              if [[ "$image" == *":"* ]]; then
                REPO="${image%:*}"
                TAG="${image##*:}"
              elif [[ "$image" == *"@"* ]]; then
                REPO="${image%@*}"
                TAG="${image##*@}"
              else
                REPO="$image"
                TAG="latest"
              fi
              
              # Add full ECR path
              echo "${ECR_REGISTRY}/${ECR_PREFIX}/${REPO},${TAG}"
            done | sort -u > added_repos
            
            echo "Images to scan:"
            cat added_repos
          else
            echo "No images artifact found"
            touch added_repos
          fi

      - name: Scan Images with Wiz
        env:
          WIZ_CLIENT_ID: ${{ secrets.WIZ_CLIENT_ID }}
          WIZ_CLIENT_SECRET: ${{ secrets.WIZ_CLIENT_SECRET }}
        run: |
          # Download the latest version of the wiz-cli
          curl -o wizcli https://wizcli.app.wiz.io/latest/wizcli && chmod +x wizcli
          export REGION="us-east-1"

          # Authenticate to Wiz
          ./wizcli auth --id "$WIZ_CLIENT_ID" --secret "$WIZ_CLIENT_SECRET"

          # Initialize results file
          touch scan_results.json
          echo "[]" > scan_results.json

          # Process each line in the format: repo,tag1,tag2,digest3,digest4,...
          while read LINE ; do
            # Skip empty lines
            [ -z "$LINE" ] && continue

            # Split the line by comma
            IFS=',' read -r REPO TAGS <<< "$LINE"

            # Extract all tags (everything after the first comma)
            TAGS=${LINE#*,}

            # Process each entry for this repo
            for TAG in ${TAGS//,/ }; do
              echo "Processing repository: $REPO with tag: $TAG"

              # Build the full image name
              if [[ "${TAG}" == "sha256:"* ]]; then
                # it's really a digest
                FULL_IMAGE="${REPO}@${TAG}"
              else
                # treat as a tag
                FULL_IMAGE="${REPO}:${TAG}"
              fi
              echo "Scanning image: $FULL_IMAGE"

              # Pull the image
              docker pull $FULL_IMAGE

              if [ $? -ne 0 ]; then
                echo "Failed to pull image $FULL_IMAGE, skipping scan"
                continue
              fi

              clean_image_name=$(echo "$FULL_IMAGE" | sed 's/[\/:]/_/g' | sed 's/[^a-zA-Z0-9_.-]/_/g')

              # Scan the image and save results
              echo "Running Wiz scan on $FULL_IMAGE"
              ./wizcli docker scan --policy "test-tpay-vulnerability-scans" --image $FULL_IMAGE --format json --no-publish > scan_results_$clean_image_name.json

            done
          done < added_repos

      - name: Process scan results
        id: process_results
        run: |
          # Make script executable
          chmod +x .github/workflows/parse-wizchanges.sh

          # Run the parsing script
          .github/workflows/parse-wizchanges.sh -d . -o .

          # Ensure all_criticals.csv exists (script creates it but ensure for downstream steps)
          touch all_criticals.csv

          # Check if critical vulnerabilities were found
          if [[ -f critical_found ]]; then
              echo "critical_found=true" >> $GITHUB_OUTPUT
          else
              echo "critical_found=false" >> $GITHUB_OUTPUT
          fi

      - name: Create Critical Vulnerabilities Summary Comment
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');

            try {
              // Check if the all_criticals.csv file exists
              if (!fs.existsSync('./all_criticals.csv')) {
                console.log('No all_criticals.csv file found, skipping summary creation');
                return;
              }

              // Find existing summary comment first
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number
              });

              const existingSummaryComment = comments.find(comment => {
                return comment.body.includes('## Critical Vulnerabilities Summary') &&
                       comment.user.login === 'github-actions[bot]';
              });

              // Read and process critical vulnerabilities
              const criticalData = fs.readFileSync('./all_criticals.csv', 'utf8');
              const lines = criticalData.trim().split('\n');

              // Group vulnerabilities by image
              const imageVulnerabilities = {};

              lines.forEach(line => {
                const parts = line.split(',');
                if (parts.length >= 3) {
                  const imageName = parts[0].trim();
                  const cveName = parts[1].trim();
                  const severity = parts[2].trim();

                  if (!imageVulnerabilities[imageName]) {
                    imageVulnerabilities[imageName] = [];
                  }

                  imageVulnerabilities[imageName].push({
                    cve: cveName,
                    severity: severity
                  });
                }
              });

              // Create the summary comment
              let commentBody = '## Critical Vulnerabilities Summary\n\n';
              commentBody += 'The following critical vulnerabilities were found in images to be mirrored:\n\n';

              Object.keys(imageVulnerabilities).forEach(image => {
                commentBody += `### ${image}\n\n`;
                commentBody += '| CVE Name | Severity |\n';
                commentBody += '|----------|----------|\n';

                imageVulnerabilities[image].forEach(vuln => {
                  commentBody += `| ${vuln.cve} | ${vuln.severity} |\n`;
                });

                commentBody += '\n';
              });

              if (existingSummaryComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existingSummaryComment.id,
                  body: commentBody
                });
                console.log('Updated existing critical vulnerabilities summary comment');
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: commentBody
                });
                console.log('Created new critical vulnerabilities summary comment');
              }
            } catch (error) {
              console.error('Error creating critical vulnerabilities summary:', error);
            }

      - name: Manage PR labels based on scan results
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number
              });

              const hasCriticalLabel = currentLabels.some(label => label.name === 'critical');
              const criticalFound = '${{ steps.process_results.outputs.critical_found }}' === 'true';

              console.log(`Has critical label: ${hasCriticalLabel}, Critical found: ${criticalFound}`);

              if (criticalFound && !hasCriticalLabel) {
                console.log('Adding "critical" label to PR');
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  labels: ['critical']
                });
              } else if (!criticalFound && hasCriticalLabel) {
                console.log('Removing "critical" label from PR');
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  name: 'critical'
                });
              }
            } catch (error) {
              console.error('Failed to manage PR labels:', error);
            }
