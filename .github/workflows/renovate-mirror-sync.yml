name: Renovate Mirror Sync

on:
  pull_request:
    types: [opened, synchronize]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to process'
        required: false
        type: string
  issue_comment:
    types: [created]

env:
  # Mirror configuration
  MIRROR_REGISTRY: "registry.internal.company.com"
  MIRROR_PREFIX: "dockerhub"
  PR_PREFIX: "[DEVOPS-1094]"

jobs:
  check-pr:
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'pull_request' && startsWith(github.event.pull_request.title, '[DEVOPS-1094]')) ||
      (github.event_name == 'workflow_dispatch') ||
      (github.event_name == 'issue_comment' && github.event.issue.pull_request && contains(github.event.comment.body, '/mirror'))
    outputs:
      should_process: ${{ steps.check.outputs.should_process }}
      pr_number: ${{ steps.check.outputs.pr_number }}
    steps:
      - name: Check PR eligibility
        id: check
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "should_process=true" >> $GITHUB_OUTPUT
            echo "pr_number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "should_process=true" >> $GITHUB_OUTPUT
            echo "pr_number=${{ github.event.inputs.pr_number || github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "issue_comment" ]]; then
            echo "should_process=true" >> $GITHUB_OUTPUT
            echo "pr_number=${{ github.event.issue.number }}" >> $GITHUB_OUTPUT
          fi

  extract-images:
    needs: check-pr
    if: needs.check-pr.outputs.should_process == 'true'
    runs-on: ubuntu-latest
    outputs:
      images: ${{ steps.extract.outputs.images }}
      charts_changed: ${{ steps.changes.outputs.charts }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha || github.sha }}

      - name: Setup Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Get changed charts
        id: changes
        run: |
          # Get list of changed chart directories
          CHARTS=""
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            # Get changed files between base and head
            echo "Checking for changed files in PR..."
            CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD || true)
            echo "Changed files:"
            echo "$CHANGED_FILES"
          else
            # For manual trigger, check all charts
            echo "Manual trigger - checking all charts..."
            CHANGED_FILES=$(find . -name "Chart.yaml" | sed 's|/Chart.yaml||' | sed 's|^./||')
          fi

          for file in $CHANGED_FILES; do
            # Skip empty lines
            [[ -z "$file" ]] && continue

            # Check if it's a chart directory or file within a chart directory
            POTENTIAL_DIRS=""

            # If it's a Chart.yaml file itself
            if [[ "$file" == *"Chart.yaml" ]]; then
              POTENTIAL_DIRS="$(dirname "$file")"
            # If it's a file, check parent directories for Chart.yaml
            elif [[ -f "$file" ]]; then
              DIR="$(dirname "$file")"
              while [[ "$DIR" != "." && "$DIR" != "/" ]]; do
                if [[ -f "$DIR/Chart.yaml" ]]; then
                  POTENTIAL_DIRS="$POTENTIAL_DIRS $DIR"
                  break
                fi
                DIR="$(dirname "$DIR")"
              done
            # If it's a directory, check if it contains Chart.yaml
            elif [[ -d "$file" ]]; then
              if [[ -f "$file/Chart.yaml" ]]; then
                POTENTIAL_DIRS="$file"
              fi
            fi

            for dir in $POTENTIAL_DIRS; do
              if [[ -f "$dir/Chart.yaml" ]]; then
                echo "Found chart: $dir"
                CHARTS="$CHARTS $dir"
              fi
            done
          done

          # Remove duplicates and clean up
          if [[ -n "$CHARTS" ]]; then
            CHARTS=$(echo $CHARTS | tr ' ' '\n' | sort -u | tr '\n' ' ' | sed 's/[[:space:]]*$//')
          fi

          echo "charts=$CHARTS" >> $GITHUB_OUTPUT
          echo "Final charts list: '$CHARTS'"

          # List charts for verification
          for chart in $CHARTS; do
            if [[ -d "$chart" ]]; then
              echo "✓ Chart directory exists: $chart"
            else
              echo "✗ Chart directory missing: $chart"
            fi
          done

      - name: Extract Docker images from charts
        id: extract
        run: |
          set -euo pipefail

          # Enable debugging
          echo "::group::Setup"

          # Make script executable
          chmod +x scripts/extract-images.sh

          # Check script exists and is readable
          if [[ ! -r scripts/extract-images.sh ]]; then
            echo "❌ Error: Script not readable at scripts/extract-images.sh"
            exit 1
          fi

          # Run extraction script
          export DEBUG=true  # Enable debug for visibility
          export MIRROR_REGISTRY="${{ env.MIRROR_REGISTRY }}"
          export MIRROR_PREFIX="${{ env.MIRROR_PREFIX }}"
          export OUTPUT_FORMAT=json

          # Get charts list
          CHARTS="${{ steps.changes.outputs.charts }}"
          echo "Processing charts: $CHARTS"

          # Check if charts exist and show their contents
          for chart in $CHARTS; do
            if [[ -d "$chart" ]]; then
              echo "✓ Chart directory exists: $chart"
              echo "Contents:"
              ls -la "$chart"
              if [[ -f "$chart/Chart.yaml" ]]; then
                echo "Chart.yaml contents:"
                cat "$chart/Chart.yaml"
              fi
              if [[ -f "$chart/values.yaml" ]]; then
                echo "values.yaml contents:"
                cat "$chart/values.yaml"
              else
                echo "⚠ No values.yaml found in $chart"
              fi
            else
              echo "⚠ Chart directory not found: $chart"
              echo "Current directory contents:"
              ls -la .
            fi
          done
          echo "::endgroup::"

          echo "::group::Extract Images"
          # Extract images from changed charts and save directly to file
          if [[ -n "$CHARTS" ]]; then
            echo "Running: scripts/extract-images.sh $CHARTS"
            echo "Current working directory: $(pwd)"
            echo "Script path check:"
            ls -la scripts/extract-images.sh

            # Run script with error handling and verbose output
            set +e  # Don't exit on error, handle it ourselves
            scripts/extract-images.sh $CHARTS > images_raw.json 2> extract_errors.log
            EXIT_CODE=$?
            set -e

            if [[ $EXIT_CODE -eq 0 ]]; then
              echo "✓ Script executed successfully"
              mv images_raw.json images.json
            else
              echo "❌ Script failed with exit code: $EXIT_CODE"
              echo "Error output:"
              cat extract_errors.log
              echo "Current directory after script:"
              pwd
              echo "Files created:"
              ls -la *.json *.log 2>/dev/null || echo "No json/log files created"

              # Check if we got partial output
              if [[ -f images_raw.json ]] && [[ -s images_raw.json ]]; then
                echo "Partial output exists, attempting to use it:"
                cat images_raw.json
                mv images_raw.json images.json
              else
                echo "No useful output generated, using empty array"
                echo "[]" > images.json
              fi
            fi

            # Show any error messages
            if [[ -f extract_errors.log ]] && [[ -s extract_errors.log ]]; then
              echo "::warning::Script stderr output:"
              cat extract_errors.log
            fi
          else
            echo "No charts to process"
            echo "[]" > images.json
          fi
          echo "::endgroup::"

          echo "::group::Validate JSON"
          # Check what we got
          echo "Raw JSON output (first 500 chars):"
          head -c 500 images.json
          echo ""

          # Validate and format the JSON
          if jq '.' images.json > images_formatted.json 2> jq_errors.log; then
            mv images_formatted.json images.json
            IMAGE_COUNT=$(jq 'length' images.json)
            echo "✓ Valid JSON with $IMAGE_COUNT images"

            # Save to GitHub output for other jobs
            echo "images<<EOF" >> $GITHUB_OUTPUT
            cat images.json >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "image_count=$IMAGE_COUNT" >> $GITHUB_OUTPUT
          else
            echo "❌ Failed to parse images JSON:"
            cat jq_errors.log
            echo "Using empty array as fallback"
            echo "[]" > images.json
            echo "images=[]" >> $GITHUB_OUTPUT
            echo "image_count=0" >> $GITHUB_OUTPUT
          fi
          echo "::endgroup::"

          echo "::group::Summary"
          # Display summary
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "📦 Image Extraction Summary:"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          if [[ -f images.json ]] && [[ $(jq 'length' images.json 2>/dev/null) -gt 0 ]]; then
            jq -r '.[] | "  • \(.original) → \(.mirror)"' images.json
          else
            echo "  No images found"
          fi
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "::endgroup::"

      - name: Upload images list
        uses: actions/upload-artifact@v4
        with:
          name: images-list
          path: images.json

  create-mirror-checklist:
    needs: [check-pr, extract-images]
    if: needs.extract-images.outputs.image_count > 0
    runs-on: ubuntu-latest
    steps:
      - name: Download images artifact
        uses: actions/download-artifact@v4
        with:
          name: images-list

      - name: Create mirror checklist comment
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const imagesJson = fs.readFileSync('images.json', 'utf8');
            const images = JSON.parse(imagesJson);
            const prNumber = ${{ needs.check-pr.outputs.pr_number || github.event.pull_request.number }};

            if (!images || images.length === 0) {
              console.log('No images found to mirror');
              return;
            }

            let commentBody = `## 🐳 Docker Images to Mirror\n\n`;
            commentBody += `This PR contains updates to Helm charts with the following Docker images:\n\n`;
            commentBody += `| Select | Original Image | Mirror Destination | Chart |\n`;
            commentBody += `|--------|----------------|-------------------|-------|\n`;

            images.forEach((img, index) => {
              commentBody += `| <input type="checkbox" id="img-${index}" data-image='${JSON.stringify(img)}' /> | \`${img.original}\` | \`${img.mirror}\` | ${img.chart} |\n`;
            });

            commentBody += `\n### Mirror Actions\n`;
            commentBody += `- [ ] Click checkboxes above to select images for mirroring\n`;
            commentBody += `- [ ] Comment \`/mirror selected\` to mirror selected images\n`;
            commentBody += `- [ ] Comment \`/mirror all\` to mirror all images\n`;
            commentBody += `- [ ] Comment \`/mirror status\` to check mirroring status\n`;
            commentBody += `\n---\n`;
            commentBody += `*🤖 Automated by Renovate Mirror Sync Action*`;

            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });

            const botComment = comments.find(comment =>
              comment.body.includes('🐳 Docker Images to Mirror')
            );

            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: commentBody
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: commentBody
              });
            }

  mirror-images:
    needs: check-pr
    if: |
      github.event_name == 'issue_comment' &&
      (contains(github.event.comment.body, '/mirror selected') || contains(github.event.comment.body, '/mirror all'))
    runs-on: ubuntu-latest
    steps:
      - name: Get images to mirror
        id: get-images
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ github.event.issue.number }};
            const comment = context.payload.comment.body;

            // Download the images artifact
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId
            });

            // Parse command
            const mirrorAll = comment.includes('/mirror all');
            let imagesToMirror = [];

            if (mirrorAll) {
              // Get all images from the artifact
              core.setOutput('mirror_all', 'true');
            } else {
              // Parse selected images from checkboxes
              // This would need frontend JS to actually work with checkboxes
              // For now, we'll parse from comment
              core.setOutput('mirror_all', 'false');
            }

      - name: Setup Docker
        uses: docker/setup-buildx-action@v3

      - name: Login to mirror registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.MIRROR_REGISTRY }}
          username: ${{ secrets.MIRROR_REGISTRY_USERNAME }}
          password: ${{ secrets.MIRROR_REGISTRY_PASSWORD }}

      - name: Mirror images
        id: mirror
        run: |
          # Download images list
          curl -L -o images.json \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/actions/artifacts/images-list/zip"

          # Create mirror script
          cat > mirror.sh << 'EOF'
          #!/bin/bash
          set -e

          IMAGES_FILE="images.json"
          MIRROR_ALL="${1:-false}"
          SUCCESS_COUNT=0
          FAIL_COUNT=0
          FAILED_IMAGES=""

          # Read images from JSON
          if [[ "$MIRROR_ALL" == "true" ]]; then
            IMAGES=$(jq -r '.[] | @json' "$IMAGES_FILE")
          else
            # For selected, we'd need to parse from comment or use a different mechanism
            IMAGES=$(jq -r '.[] | @json' "$IMAGES_FILE")
          fi

          while IFS= read -r img_json; do
            IMAGE_DATA=$(echo "$img_json" | jq -r '.')
            ORIGINAL=$(echo "$IMAGE_DATA" | jq -r '.original')
            MIRROR=$(echo "$IMAGE_DATA" | jq -r '.mirror')

            echo "Mirroring: $ORIGINAL -> $MIRROR"

            # Pull original image
            if docker pull "$ORIGINAL"; then
              # Tag for mirror
              docker tag "$ORIGINAL" "$MIRROR"

              # Push to mirror
              if docker push "$MIRROR"; then
                echo "✅ Successfully mirrored: $ORIGINAL"
                ((SUCCESS_COUNT++))
              else
                echo "❌ Failed to push: $MIRROR"
                ((FAIL_COUNT++))
                FAILED_IMAGES="$FAILED_IMAGES\n- $ORIGINAL"
              fi
            else
              echo "❌ Failed to pull: $ORIGINAL"
              ((FAIL_COUNT++))
              FAILED_IMAGES="$FAILED_IMAGES\n- $ORIGINAL"
            fi
          done <<< "$IMAGES"

          # Output summary
          echo "mirror_success=$SUCCESS_COUNT" >> $GITHUB_OUTPUT
          echo "mirror_failed=$FAIL_COUNT" >> $GITHUB_OUTPUT
          echo "failed_images<<EOF" >> $GITHUB_OUTPUT
          echo -e "$FAILED_IMAGES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          EOF

          chmod +x mirror.sh
          ./mirror.sh "${{ steps.get-images.outputs.mirror_all }}"

      - name: Post mirror results
        uses: actions/github-script@v7
        with:
          script: |
            const success = ${{ steps.mirror.outputs.mirror_success || 0 }};
            const failed = ${{ steps.mirror.outputs.mirror_failed || 0 }};
            const failedImages = `${{ steps.mirror.outputs.failed_images }}`;
            const prNumber = ${{ github.event.issue.number }};

            let commentBody = `## ✅ Mirror Operation Complete\n\n`;
            commentBody += `- **Successful**: ${success} images\n`;
            commentBody += `- **Failed**: ${failed} images\n`;

            if (failed > 0 && failedImages) {
              commentBody += `\n### Failed Images:\n${failedImages}\n`;
            }

            if (failed === 0 && success > 0) {
              commentBody += `\n🎉 **All images successfully mirrored!** The PR is now ready for merge.\n`;

              // Approve the PR
              await github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                event: 'APPROVE',
                body: 'All Docker images have been successfully mirrored to the private registry.'
              });
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: commentBody
            });

  status-check:
    needs: check-pr
    if: |
      github.event_name == 'issue_comment' &&
      contains(github.event.comment.body, '/mirror status')
    runs-on: ubuntu-latest
    steps:
      - name: Check mirror status
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ github.event.issue.number }};

            // Get PR reviews
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            const approved = reviews.some(review => review.state === 'APPROVED');

            let statusBody = `## 📊 Mirror Status\n\n`;

            if (approved) {
              statusBody += `✅ **This PR has been approved** - All images have been mirrored successfully.\n`;
            } else {
              statusBody += `⏳ **Awaiting mirror completion** - Please select and mirror the required images.\n`;
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: statusBody
            });